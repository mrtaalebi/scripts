#!/bin/bash

# licensed to GPL

help() {
    echo ""
    echo "    dyg stands for DownYouGo and is a cli multi-proccess download manager"
    echo "    downloaded files will be saved to ~/Downloads/"
    echo ""
    echo "    *******************************************************************************"
    echo "    to make sure you have all the following requirements installed run the command:"
    echo "        sudo apt install curl gawk dos2unix bc"
    echo "    *******************************************************************************"
    echo ""
    echo "    usage:"
    echo "        to download a new file:"
    echo "            dyg <link> [param values]"
    echo "        params:"
    echo "            -n|--number    number of partitions (default: 16)"
    echo "            -o|--out       output file (default: file basename)"
    echo "            -b|--background continue in background (default: false)"
    echo "            -h|--help      shows this help and exit"
    echo ""
}

input() {    
    if (($# < 1)); then
        help
        exit 1
    fi

    link="$1"
    shift

    background=0

    while (($# > 0)); do
        case "$1" in
            -n|--number)
                number="$2"
                shift
                shift
                ;;
            -o|--out)
                output="$2"
                shift
                shift
                ;;
            -b|--background)
                background=1
                shift
                ;; 
            -h|--help|*)
                help 
                exit 0
                shift
                ;;
        esac
    done;

    if [ -z "$link" ]; then
        echo "link not given, exiting"
        exit 0
    fi

    if [ -z "$output" ]; then
        output=`basename $link`
    fi
    if [ -f ~/Downloads/$output ]; then
        echo "    file already exists, exiting"
        exit 0
    fi
    echo "    saving to ~/Downloads/$output"

    if [ -f ~/Downloads/.dyg/info/$output ]; then
        number=`cat ~/Downloads/.dyg/info/$output`
    elif [ -z "$number" ]; then
        number=16
    fi
    echo "    downloading in $number processes"
}


link=""
number=""
output=""

input "$@"

head=`curl --head $link 2>&1`
if [ -z "$head" ]; then
    echo "server has not responded to head request, exiting"
    exit 1
fi

length=`curl --head $link 2>&1 | grep --ignore-case "content-length: [0-9]*" | awk '{print $2}' | dos2unix`
if [ -z "$length" ]; then
    echo "server bad response to curl --head $link, exiting"
    exit 1
fi


mkdir -p ~/Downloads/.dyg/temp/$output
mkdir -p ~/Downloads/.dyg/log/$output
mkdir -p ~/Downloads/.dyg/info
cd ~/Downloads/.dyg

echo $link >> .list

echo "    writing parts info to ~/Downloads/.dyg/info/$output"
echo "$number" > info/$output
byte_on=0
part_length=`bc -l <<< "scale=0; $length / $number"`
for ((i=0; i < number; i++)); do
    if [ -f temp/$output/$i.temp ]; then
        currently_downloaded=`stat -c '%n %s' temp/$output/$i.temp | awk '{print $2}'`
        if [ $currently_downloaded -ge $part_length ]; then
            let "byte_on+=part_length" 
            continue
        fi
        start_from=`bc -l <<< "scale=0; $currently_downloaded + $byte_on"`
    else
        start_from=$byte_on
    fi
    if (($i == $number - 1)); then
        range="$start_from-"
    else
        range="$start_from-$((byte_on + part_length - 1))"
    fi
    let "byte_on+=part_length"
    curl -s -H "Range: bytes=$range" --get $link >> temp/$output/$i.temp 2>&1 &
done


if [ $background -eq 1 ]; then
    echo "    continuing in background"
    kill -SIGSTOP $$
    kill -SIGCONT $$
fi


a=$((31 + RANDOM % 6))
color=$a
a="m"
color="$color$a"


echo 
start_sec=`date +"%s"`
last_sum=0
while ((1)); do
    printf "\033[2K\033[7m\t\033[$color      downloading      \033[0m\n"
    parts_sum=0
    for ((i=0;i < number; i++)); do
        if [ ! -f temp/$output/$i.temp ]; then
            part_size=0
        else
            part_size=`stat -c '%n %s' temp/$output/$i.temp | awk '{print $2}'`
        fi
        parts_sum=$((parts_sum + part_size))
        printf "\033[2K\t\033[${color}part %03d:\t%6.2f%%\033[0m\n" "$i" `bc -l <<< "scale=4; $part_size / $part_length * 100"`
    done
    printf "\033[2K\033[7m\t\033[${color}total:% 16.2f%%\033[0m\n" `bc -l <<< "scale=4; $parts_sum / $length * 100"`
    printf "\033[2K\033[7m\t\033[${color}speed:% 12.2f MB/s\033[0m\n" `bc -l <<< "scale=4; ($parts_sum - $last_sum) / 1024 / 1024"`
    last_sum=$parts_sum
    printf "\033[$((number + 3))A"

    if [ "$parts_sum" -eq "$length" ]; then
        break;
    fi
    sleep 1
done
printf "\033[$((number + 3))B"
end_sec=`date +"%s"`


wait


cd temp/$output
list=`ls * | sort -n`
printf "\t\033[${color}successfully downloaded\033[0m\n"
printf "\033[7m\t\033[${color}content:% 12.2f MB\033[0m\n" `bc -l <<< "scale=4; $length / 1024 / 1024"`
printf "\033[2K\033[7m\t\033[${color}in:% 18.2f m\033[0m\n" `bc -l <<< "scale=4; ($end_sec - $start_sec + 1) / 60"`
printf "\033[2K\033[7m\t\033[${color}with:% 13.2f MB/s\033[0m\n" `bc -l <<< "scale=4; $length / 1024 / 1024 / ($end_sec - $start_sec + 1)"`
cat $list > ../../../$output

cd ../..
rm -r temp/$output*

